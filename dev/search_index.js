var documenterSearchIndex = {"docs":
[{"location":"migration-v1/#Migration-Guide:-Upgrading-to-AutoMerge-v1","page":"Migration Guide (AutoMerge v1)","title":"Migration Guide: Upgrading to AutoMerge v1","text":"AutoMerge v1 replaces the single AutoMerge.run() function with two separate entrypoints with different privilege levels. This guide will help you migrate from the pre-v1 API to the new v1 API.\n\nnote: AutoMerge is now a standalone package\nPrior to v1, AutoMerge was a submodule of RegistryCI.jl. As of v1, AutoMerge has been split into its own independent package with its own versioning and release cycle.","category":"section"},{"location":"migration-v1/#Key-Changes-in-v1","page":"Migration Guide (AutoMerge v1)","title":"Key Changes in v1","text":"Split Entrypoints: The single AutoMerge.run() function has been replaced with two separate functions:\nAutoMerge.check_pr(): Validates pull requests (runs untrusted code, minimal permissions)\nAutoMerge.merge_prs(): Merges approved pull requests (elevated permissions, no untrusted code)\nConfiguration Structs: Keyword arguments are now organized into three configuration structs:\nRegistryConfiguration: Shared registry settings\nCheckPRConfiguration: PR validation settings\nMergePRsConfiguration: PR merging settings\nEnvironment Variables: Token configuration has changed:\nPre-v1: Single GITHUB_TOKEN or custom token variable\nv1: Two separate tokens with different permission levels:\nAUTOMERGE_GITHUB_TOKEN: For PR checking (read access + commit status)\nAUTOMERGE_MERGE_TOKEN: For PR merging (write access)","category":"section"},{"location":"migration-v1/#Migration-Steps","page":"Migration Guide (AutoMerge v1)","title":"Migration Steps","text":"","category":"section"},{"location":"migration-v1/#Step-1:-Update-Your-Configuration","page":"Migration Guide (AutoMerge v1)","title":"Step 1: Update Your Configuration","text":"The recommended approach is to use TOML configuration files. You can create a configuration file for your registry based on the General registry configuration:\n\nusing AutoMerge\n\n# Create a template configuration file\nconfig = AutoMerge.general_registry_config()\nAutoMerge.write_config(\"MyRegistry.AutoMerge.toml\", config)\n\nThen customize the TOML file for your registry's needs. See the Configuration page for details on all available configuration options for:\n\nRegistryConfiguration - shared registry settings\nCheckPRConfiguration - PR validation settings\nMergePRsConfiguration - PR merging settings\n\nwarning: Time Period Changes\nIn v1, time periods are now specified in minutes (Minute type) instead of arbitrary Period types. Field names have been updated from *_period to *_minutes. For example:new_package_waiting_period = Day(3) becomes new_package_waiting_minutes = Minute(Day(3))\nnew_version_waiting_period = Minute(10) becomes new_version_waiting_minutes = Minute(10)","category":"section"},{"location":"migration-v1/#Step-2:-Update-Environment-Variables-for-Separate-Jobs","page":"Migration Guide (AutoMerge v1)","title":"Step 2: Update Environment Variables for Separate Jobs","text":"Important: The two entrypoints should run in separate GitHub Actions jobs with different environment variables to ensure tokens are only exposed to the operations that need them.\n\nPR Check Job: Only needs AUTOMERGE_GITHUB_TOKEN (read access + commit status)\nPR Merge Job: Needs both AUTOMERGE_GITHUB_TOKEN and AUTOMERGE_MERGE_TOKEN (write access)\n\nThis separation ensures that:\n\nThe PR checking job (which runs untrusted code) never has access to the merge token\nThe principle of least privilege is maintained\n\nnote: Token Permissions\nAUTOMERGE_GITHUB_TOKEN needs repo:status permission and read access to PRs\nAUTOMERGE_MERGE_TOKEN needs write access to the repositoryFor most registries, you can use secrets.GITHUB_TOKEN for AUTOMERGE_GITHUB_TOKEN and a more privileged token (like secrets.TAGBOT_TOKEN) for AUTOMERGE_MERGE_TOKEN.","category":"section"},{"location":"migration-v1/#Step-3:-Update-GitHub-Workflow-Files","page":"Migration Guide (AutoMerge v1)","title":"Step 3: Update GitHub Workflow Files","text":"Create separate jobs for PR checking and PR merging:\n\nAfter (v1):\n\njobs:\n  AutoMerge-PR-Check:\n    runs-on: ubuntu-latest\n    steps:\n      # ... setup steps ...\n      - name: AutoMerge PR Check\n        env:\n          AUTOMERGE_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: |\n          config = AutoMerge.read_config(\"MyRegistry.AutoMerge.toml\")\n          AutoMerge.check_pr(config.registry_config, config.check_pr_config)\n        shell: julia --color=yes --project=.ci/ {0}\n\n  AutoMerge-PR-Merge:\n    runs-on: ubuntu-latest\n    steps:\n      # ... setup steps ...\n      - name: AutoMerge PR Merge\n        env:\n          AUTOMERGE_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          AUTOMERGE_MERGE_TOKEN: ${{ secrets.TAGBOT_TOKEN }}\n        run: |\n          config = AutoMerge.read_config(\"MyRegistry.AutoMerge.toml\")\n          AutoMerge.merge_prs(config.registry_config, config.merge_prs_config)\n        shell: julia --color=yes --project=.ci/ {0}\n\nSee the Configuration page for a complete example workflow file with proper job separation and conditional execution.","category":"section"},{"location":"guidelines/#Automatic-merging-guidelines","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"These are the guidelines that a pull request must pass in order to be automatically merged.\n\nAll of those guidelines are enabled on the General registry (see AutoMerge.general_registry_config for the precise configuration of AutoMerge used by General).\n\nFor other registries, some of these guidelines can be disabled.","category":"section"},{"location":"guidelines/#New-packages","page":"Automatic merging guidelines","title":"New packages","text":"import RegistryCI\nimport AutoMerge\nimport Markdown\n\nfunction guidelines_to_markdown_output(guidelines_function::Function)\n    guidelines = guidelines_function(\n        registration_type;\n        check_license = true,\n        check_breaking_explanation = true,\n        this_is_jll_package = false,\n        this_pr_can_use_special_jll_exceptions = false,\n        use_distance_check = false,\n        package_author_approved = false,\n    )\n    filter!(x -> !(x[1] isa Symbol), guidelines)\n    filter!(x -> !(x[1].docs isa Nothing), guidelines)\n    docs = [rstrip(x[1].docs) for x in guidelines]\n    output_string = join(string.(collect(1:length(docs)), Ref(\". \"), docs), \"\\n\")\n    output_markdown = Markdown.parse(output_string)\n    return output_markdown\nend\n\nconst guidelines_function = AutoMerge.get_automerge_guidelines\nconst registration_type = AutoMerge.NewPackage()\nconst output_markdown = guidelines_to_markdown_output(guidelines_function)\n\nreturn output_markdown","category":"section"},{"location":"guidelines/#New-versions-of-existing-packages","page":"Automatic merging guidelines","title":"New versions of existing packages","text":"import RegistryCI\nimport AutoMerge\nimport Markdown\n\nfunction guidelines_to_markdown_output(guidelines_function::Function)\n    guidelines = guidelines_function(\n        registration_type;\n        check_license = true,\n        check_breaking_explanation = true,\n        this_is_jll_package = false,\n        this_pr_can_use_special_jll_exceptions = false,\n        use_distance_check = false,\n        package_author_approved = false,\n    )\n    filter!(x -> !(x[1] isa Symbol), guidelines)\n    filter!(x -> !(x[1].docs isa Nothing), guidelines)\n    docs = [rstrip(x[1].docs) for x in guidelines]\n    output_string = join(string.(collect(1:length(docs)), Ref(\". \"), docs), \"\\n\")\n    output_markdown = Markdown.parse(output_string)\n    return output_markdown\nend\n\nconst guidelines_function = AutoMerge.get_automerge_guidelines\nconst registration_type = AutoMerge.NewVersion()\nconst output_markdown = guidelines_to_markdown_output(guidelines_function)\n\nreturn output_markdown","category":"section"},{"location":"guidelines/#Additional-information","page":"Automatic merging guidelines","title":"Additional information","text":"","category":"section"},{"location":"guidelines/#Upper-bounded-[compat]-entries","page":"Automatic merging guidelines","title":"Upper-bounded [compat] entries","text":"For example, the following [compat] entries meet the criteria for automatic merging:\n\n[compat]\nPackageA = \"1\"          # [1.0.0, 2.0.0), has upper bound (good)\nPackageB = \"0.1, 0.2\"   # [0.1.0, 0.3.0), has upper bound (good)\n\nThe following [compat] entries do NOT meet the criteria for automatic merging:\n\n[compat]\nPackageC = \">=3\"        # [3.0.0, ∞), no upper bound (bad)\nPackageD = \">=0.4, <1\"  # [0, ∞), no lower bound, no upper bound (very bad)\n\nPlease note: each [compat] entry must include only a finite number of breaking releases. Therefore, the following [compat] entries do NOT meet the criteria for automatic merging:\n\n[compat]\nPackageE = \"0\"          # includes infinitely many breaking 0.x releases of PackageE (bad)\nPackageF = \"0.2 - 0\"    # includes infinitely many breaking 0.x releases of PackageF (bad)\nPackageG = \"0.2 - 1\"    # includes infinitely many breaking 0.x releases of PackageG (bad)\n\nSee Pkg's documentation for specification of [compat] entries in your Project.toml file.\n\n(Note: JLL dependencies are excluded from this criterion because they often have non-standard version numbering schemes; however, this may change in the future.)\n\nYou may find CompatHelper.jl and PackageCompatUI.jl helpful for maintaining up-to-date [compat] entries.","category":"section"},{"location":"guidelines/#Testing-that-the-package-can-be-imported","page":"Automatic merging guidelines","title":"Testing that the package can be imported","text":"AutoMerge tests whether the registered package/version can be imported. This is done using the lowest and highest Julia minor versions according to the Julia compat declared in Project.toml. For the chosen minor versions, the highest compatible patch version is used. There are two special cases:\n\nFor technical reasons 1.0.x versions cannot be used, so effectively 1.1 is the lowest considered minor version.\nIf a package only is compatible with a Julia version in prerelease testing phase, the highest available prerelease version (e.g. a beta or a release candidate) is used for import testing. Otherwise prereleases are not used.","category":"section"},{"location":"guidelines/#Name-similarity-distance-check","page":"Automatic merging guidelines","title":"Name similarity distance check","text":"These checks and tolerances are subject to change in order to improve the process.\n\nTo test yourself that a tentative package name, say MyPackage meets these checks, you can use the following code (after adding the RegistryCI package to your Julia environment):\n\nusing RegistryCI, RegistryInstances\nusing AutoMerge\npath_to_registry = joinpath(DEPOT_PATH[1], \"registries\", \"General.toml\")\nall_pkg_names = AutoMerge.get_all_pkg_names(RegistryInstance(path_to_registry); keep_jll=false)\nAutoMerge.meets_distance_check(\"MyPackage123\", all_pkg_names)\n\nwhere path_to_registry is a path to the registry of interest. For the General Julia registry, usually path_to_registry = joinpath(DEPOT_PATH[1], \"registries\", \"General.toml\") if you haven't changed your DEPOT_PATH (or path_to_registry = joinpath(DEPOT_PATH[1], \"registries\", \"General\") if you have an uncompressed registry at the directory there). This will return a boolean, indicating whether or not your tentative package name passed the check, as well as a string, indicating what the problem is in the event the check did not pass.\n\nNote that these automerge guidelines are deliberately conservative: it is very possible for a perfectly good name to not pass the automatic checks. They simply exist to provide a fast path so that manual review is not required for every new package. False positives can be overridden with a PR label after manual review.","category":"section"},{"location":"guidelines/#Providing-and-updating-release-notes","page":"Automatic merging guidelines","title":"Providing and updating release notes","text":"When invoking a registration with the @JuliaRegister bot, release notes can be added in the form\n\n@JuliaRegistrator register\n\nRelease notes:\n\n## Breaking changes\n\n- Explanation of breaking change, ideally with upgrade tips\n- ...\n\nThese can also be added/updated on the General PR by re-invoking with the above.\n\nDoing this has two benefits:\n\nhelps explanations during the registration process, especially for breaking changes\nrelease notes are picked up by TagBot such that they are added to the new release on the original repo\n\nAutomerge is disabled for breaking changes where release notes are not provided mentioning \"breaking\" (or \"changelog\" if there is a repository file that you prefer to direct users to).","category":"section"},{"location":"guidelines/#List-of-all-GitHub-PR-labels-that-can-influence-AutoMerge","page":"Automatic merging guidelines","title":"List of all GitHub PR labels that can influence AutoMerge","text":"AutoMerge reads certain labels on GitHub registration pull requests to influence its decisions. Specifically, these labels are:\n\nOverride AutoMerge: name similarity is okay\nThis label can be manually applied by folks with triage-level access to the registry repository.\nAutoMerge skips the \"name similarity check\" on new package registration PRs with this label.\nOverride AutoMerge: package author approved\nThis label can be manually applied, but typically is applied by a separate Github Actions workflow which monitors the PR for comments by the package author, and applies this label if they write [merge approved].\nThis label currently only skips the \"sequential version number\" check in new versions. In the future, the author-approval mechanism may be used for other checks (on both \"new version\" registrations and also \"new package\" registrations).\nWhen AutoMerge fails a check that can be skipped by author-approval, it will mention so in the comment, and direct authors to comment [merge approved] if they want to skip the check.","category":"section"},{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/#RegistryCI","page":"Public API","title":"RegistryCI","text":"","category":"section"},{"location":"public/#AutoMerge","page":"Public API","title":"AutoMerge","text":"","category":"section"},{"location":"public/#Main-Entrypoints","page":"Public API","title":"Main Entrypoints","text":"","category":"section"},{"location":"public/#Configuration-Types","page":"Public API","title":"Configuration Types","text":"For configuration information, see the Configuration page.","category":"section"},{"location":"public/#RegistryCI.test","page":"Public API","title":"RegistryCI.test","text":"test(path)\n\nRun various checks on the registry located at path. Checks for example that all files are parsable and understandable by Pkg and consistency between Registry.toml and each Package.toml.\n\nIf your registry has packages that have dependencies that are registered in other registries elsewhere, then you may provide the github urls for those registries using the registry_deps parameter.\n\n\n\n\n\n","category":"function"},{"location":"public/#AutoMerge.check_pr","page":"Public API","title":"AutoMerge.check_pr","text":"check_pr(registry_config::RegistryConfiguration, pr_config::CheckPRConfiguration, env=ENV, cicfg::CIService=auto_detect_ci_service(; env=env))\n\nCheck a pull request for registration validity. This entrypoint runs untrusted code and does not require merge permissions.\n\nArguments\n\nregistry_config: RegistryConfiguration struct containing shared registry settings\npr_config: CheckPRConfiguration struct containing PR validation specific settings\nenv: an AbstractDictionary used to read environmental variables from.  Defaults to ENV but a plain Dict can be passed to mimic an alternate environment.\ncicfg: Configuration struct describing the continuous integration (CI) environment in which AutoMerge is being run.\n\nExample\n\nHere is an example of how General registry is configured:\n\nusing AutoMerge\n(; registry_config, check_pr_config) = AutoMerge.general_registry_config()\nAutoMerge.check_pr(registry_config, check_pr_config)\n\nTo configure a custom registry, save a .toml configuration file somewhere. This can be based on the one General uses, which you can obtain by\n\nconfig = AutoMerge.general_registry_config()\nAutoMerge.write_config(\"AutoMerge.toml\", config)\n\nand then modify to suit your needs. This can then be used via:\n\nusing AutoMerge\n(; registry_config, check_pr_config) = AutoMerge.read_config(\"path/to/AutoMerge.toml\")\nAutoMerge.check_pr(registry_config, check_pr_config)\n\n\n\n\n\n","category":"function"},{"location":"public/#AutoMerge.merge_prs","page":"Public API","title":"AutoMerge.merge_prs","text":"merge_prs(registry_config::RegistryConfiguration, merge_config::MergePRsConfiguration, env=ENV, cicfg::CIService=auto_detect_ci_service(; env=env))\n\nMerge approved pull requests. This entrypoint requires merge permissions and does not run untrusted code.\n\nArguments\n\nregistry_config: RegistryConfiguration struct containing shared registry settings\nmerge_config: MergePRsConfiguration struct containing merge specific settings\nenv: an AbstractDictionary used to read environmental variables from.  Defaults to ENV but a plain Dict can be passed to mimic an alternate environment.\ncicfg: Configuration struct describing the continuous integration (CI) environment in which AutoMerge is being run.\n\nExample\n\nHere is an example of how General registry is configured:\n\nusing AutoMerge\n\n(; registry_config, merge_prs_config) = AutoMerge.general_registry_config()\nAutoMerge.merge_prs(registry_config, merge_prs_config)\n\n\n\n\n\n","category":"function"},{"location":"regexes/#Regexes","page":"Regexes","title":"Regexes","text":"In order for AutoMerge to work, each pull request (PR) must match the following regular expressions:\n\nimport RegistryCI\nimport AutoMerge\nimport Markdown\n\nBase.@kwdef struct TableRow\n    regex::Regex\n    regex_str::String\n    pr_field::String\n    pr_type::String\n    example::String\nend\n\nescape_pipes(str::String) = replace(str, \"|\" => \"\\\\|\")\n\nfunction table_row(; regex::Regex,\n                     pr_field::String,\n                     pr_type::String,\n                     example::String)\n    regex_str = regex |> Base.repr |> escape_pipes\n    result = TableRow(;\n            regex,\n            regex_str,\n            pr_field,\n            pr_type,\n            example,\n        )\n    return result\nend\n\nconst row_1 = table_row(;\n    regex = AutoMerge.new_package_title_regex,\n    pr_field = \"PR title\",\n    pr_type = \"New packages\",\n    example = \"New package: HelloWorld v1.2.3\",\n)\n\nconst row_2 = table_row(;\n    regex = AutoMerge.new_version_title_regex,\n    pr_field = \"PR title\",\n    pr_type = \"New versions\",\n    example = \"New version: HelloWorld v1.2.3\",\n)\n\nconst row_3 = table_row(;\n    regex = AutoMerge.commit_regex,\n    pr_field = \"PR body\",\n    pr_type = \"All\",\n    example = \"* Commit: 012345678901234567890123456789abcdef0000\",\n)\n\nconst rows = [\n    row_1,\n    row_2,\n    row_3,\n]\n\nfor row in rows\n    regex_occurs_in_example = occursin(row.regex, row.example)\n    if !regex_occurs_in_example\n        @error(\"Regex does not occur in example\", row.regex, row.example)\n        throw(ErrorException(\"Regex `$(row.regex)` does not occur in example \\\"$(row.example)\\\"\"))\n    end\nend\n\nconst markdown_lines = String[\n    \"| Regex | Field | PR Type | Example |\",\n    \"| ----- | ----- | ------- | ------- |\",\n]\n\nfor row in rows\n    line = \"| `$(row.regex_str)` | $(row.pr_field) | $(row.pr_type) | `$(row.example)` |\"\n    push!(markdown_lines, line)\nend\n\nconst markdown_string = join(markdown_lines, \"\\n\")\nconst markdown_parsed = Markdown.parse(markdown_string)\n\nreturn markdown_parsed","category":"section"},{"location":"private-registries/#Using-RegistryCI-on-your-own-package-registry","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"In order to create and maintain a custom Julia registry, you can use LocalRegistry.jl. After you have the registry configured, you can setup CI using RegistryCI by following how it is used in the General registry.","category":"section"},{"location":"private-registries/#Basic-configuration","page":"Using RegistryCI on your own package registry","title":"Basic configuration","text":"You will first need to copy the .ci folder in the root of the General registry to the root of your own registry. This folder contains some resources required for the RegistryCI package to work and update itself. If you do not need AutoMerge support, there is no need to copy the stopwatch.jl file in the .ci folder.\n\nNext, you will need to copy the registry-consistency-ci.yml and update_manifest.yml workflow files.\n\nThe registry-consistency-ci.yml file should be modified as follows if you have packages in your registry that depend on packages in the General registry. If the packages in your registry depend on packages in other registries, they should also be added to registry_deps\n\n- run: julia --project=.ci/ --color=yes -e 'import RegistryCI; RegistryCI.test()'\n\n+ run: julia --project=.ci/ --color=yes -e 'import RegistryCI; RegistryCI.test(registry_deps=[\"https://github.com/JuliaRegistries/General\"])'\n\nYou can optionally use the registry name instead of the URL:\n\n- run: julia --project=.ci/ --color=yes -e 'import RegistryCI; RegistryCI.test()'\n+ run: julia --project=.ci/ --color=yes -e 'import RegistryCI; RegistryCI.test(registry_deps=[\"General\"])'\n\nIf Julia pkg server is available and recognized, then the Julia Pkg will try to download registry from it. This can be useful to reduce the unnecessary network traffic, for example, if you host a private pkg server in your local network(e.g., enterprise network with firewall) and properly set up the environment variable JULIA_PKG_SERVER, then the network traffic doesn't need to pass through the proxy to GitHub.\n\nwarning: Warning\nRegistry fetched from Julia pkg server currently has some observable latency(e.g., hours). Check here for more information.\n\nThe self-update mechanism mentioned above uses a TAGBOT_TOKEN secret in order to create a pull request with the update. This secret is a personal access token which must have the repo scope enabled. To create the repository secret follow the instructions here. Use the name TAGBOT_TOKEN and the new PAT as the value.","category":"section"},{"location":"private-registries/#TagBot-triggers","page":"Using RegistryCI on your own package registry","title":"TagBot triggers","text":"If you want to use TagBot in the packages that you register in your registry, you need to also copy the TagBotTriggers.yml file. That workflow file also needs the TAGBOT_TOKEN secret mentioned above. In the TagBot.yml workflows of the registered packages you will also need to add the registry input as stated in the TagBot readme\n\nwith:\n  token: ${{ secrets.GITHUB_TOKEN }}\n  registry: MyOrg/MyRegistry","category":"section"},{"location":"private-registries/#AutoMerge-support","page":"Using RegistryCI on your own package registry","title":"AutoMerge support","text":"In order to enable automerge support, you will also have to copy the automerge.yml file and configure AutoMerge appropriately.\n\ninfo: Configuration Details\nFor comprehensive AutoMerge configuration information, see the Configuration page.","category":"section"},{"location":"private-registries/#Basic-Setup","page":"Using RegistryCI on your own package registry","title":"Basic Setup","text":"AutoMerge uses separate entrypoints for security isolation:\n\ncheck_pr: Validates PRs (runs untrusted code, minimal permissions)\nmerge_prs: Merges approved PRs (elevated permissions, no untrusted code)\n\nusing AutoMerge\n\n# Load configuration (see Configuration page for creation details)\nconfig = AutoMerge.read_config(\"MyRegistry.AutoMerge.toml\")\n\n# In PR checking workflow\nAutoMerge.check_pr(config.registry_config, config.check_pr_config)\n\n# In merge workflow\nAutoMerge.merge_prs(config.registry_config, config.merge_prs_config)\n\nMost importantly, the following configuration settings must be updated for your registry:\n\n[registry_config]\nregistry = \"MyOrg/MyRegistry\"\nauthorized_authors = [\"TrustedUser\"]\n\nYou will also have to make the following change in .ci/stopwatch.jl\n\n- registry = GitHub.Repo(\"JuliaRegistries/General\")\n+ registry = GitHub.Repo(\"MyOrg/MyRegistry\")","category":"section"},{"location":"private-registries/#Note-regarding-private-registries","page":"Using RegistryCI on your own package registry","title":"Note regarding private registries","text":"In the case of a private registry, you might get permission errors when executing the instantiate.sh script. In that case you will also have to add the following\n\n  - run: chmod 400 .ci/Project.toml\n  - run: chmod 400 .ci/Manifest.toml\n+ - run: chmod +x .ci/instantiate.sh\n\nin registry-consistency-ci.yml and also TagBotTriggers.yml and automerge.yml (in which the above appears twice) files if those features are used.","category":"section"},{"location":"private-registries/#Author-approval-workflow-support","page":"Using RegistryCI on your own package registry","title":"Author approval workflow support","text":"Some guidelines allow the person invoking registration (typically the package author) to \"approve\" AutoMerge even if the guideline is not passing. This is facilitated by a labelling workflow author_approval.yml that must run on the registry in order to translate author-approval comments into labels that AutoMerge can use. The General registry's workflows should once again be used as an example.","category":"section"},{"location":"configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"configuration/#AutoMerge.jl","page":"Configuration","title":"AutoMerge.jl","text":"AutoMerge.jl provides automatic merging functionality for Julia package registries. The package has been designed with security in mind, separating functionality into two distinct entrypoints with different privilege levels:\n\ncheck_pr: Validates pull requests by running untrusted code but requires only minimal GitHub permissions (commit status updates and PR read access)\nmerge_prs: Merges approved pull requests but requires elevated GitHub permissions (repository write access) and does not run untrusted code","category":"section"},{"location":"configuration/#Configuration-Overview","page":"Configuration","title":"Configuration Overview","text":"AutoMerge uses three separate configuration objects to maintain clear separation of concerns:\n\nThe AutoMerge.AutoMergeConfiguration combines all 3 into one object:","category":"section"},{"location":"configuration/#General-Registry-Configuration","page":"Configuration","title":"General Registry Configuration","text":"The General registry provides a pre-configured setup that can be used as a reference:","category":"section"},{"location":"configuration/#Configuration-Management","page":"Configuration","title":"Configuration Management","text":"","category":"section"},{"location":"configuration/#Basic-Usage","page":"Configuration","title":"Basic Usage","text":"","category":"section"},{"location":"configuration/#Using-the-General-Registry-Configuration","page":"Configuration","title":"Using the General Registry Configuration","text":"For the General registry, you can use the pre-configured settings:\n\nusing AutoMerge\n\n# Get the General registry configuration\nconfig = AutoMerge.general_registry_config()\n\n# For PR checking (runs untrusted code, minimal permissions)\nAutoMerge.check_pr(config.registry_config, config.check_pr_config)\n\n# For PR merging (elevated permissions, no untrusted code)\nAutoMerge.merge_prs(config.registry_config, config.merge_prs_config)","category":"section"},{"location":"configuration/#Creating-a-Custom-Configuration","page":"Configuration","title":"Creating a Custom Configuration","text":"For a custom registry, create a TOML configuration file. This can be based on the one used by General:\n\nimport Markdown\nstr =\"```toml\\n\" * \n    read(\"../../AutoMerge/configs/General.AutoMerge.toml\", String) *\n    \"\\n```\"\n@eval Markdown.@md_str($str)\n\nWe suggest the naming convention $Registry.AutoMerge.toml.\n\nThen use the configuration:\n\n# Load configuration\nconfig = AutoMerge.read_config(\"MyRegistry.AutoMerge.toml\")\n\n# Use in CI workflows\nAutoMerge.check_pr(config.registry_config, config.check_pr_config)\nAutoMerge.merge_prs(config.registry_config, config.merge_prs_config)","category":"section"},{"location":"configuration/#Security-Considerations","page":"Configuration","title":"Security Considerations","text":"","category":"section"},{"location":"configuration/#GitHub-Token-Configuration","page":"Configuration","title":"GitHub Token Configuration","text":"AutoMerge uses separate GitHub tokens with minimal required permissions:\n\nToken Scopes Required Used By Purpose\ncommit_status_token_name repo:status, read PRs check_pr Set commit statuses during PR validation\nmerge_token_name pull_request:write, contents:write merge_prs Merge approved PRs\n\nDefault values:\n\ncommit_status_token_name = \"AUTOMERGE_GITHUB_TOKEN\"\nmerge_token_name = \"AUTOMERGE_MERGE_TOKEN\"\n\nFor General registry, these tokens are separated to follow the principle of least privilege: the PR checking job (which runs untrusted code) never has access to the merge token.\n\nwarning: Token Security\nThese fields store environment variable names, not token values. Never put actual tokens in configuration files.","category":"section"},{"location":"configuration/#Separation-of-Privileges","page":"Configuration","title":"Separation of Privileges","text":"The two-entrypoint design ensures that:\n\nPR checking (check_pr) runs untrusted package code during validation but only has minimal GitHub permissions\nPR merging (merge_prs) has elevated GitHub permissions but never runs untrusted code\n\nThis separation follows the principle of least privilege and reduces the attack surface.","category":"section"},{"location":"configuration/#CI-Workflow-Integration","page":"Configuration","title":"CI Workflow Integration","text":"","category":"section"},{"location":"configuration/#GitHub-Actions-Example","page":"Configuration","title":"GitHub Actions Example","text":"import Markdown\nstr =\"```yaml\\n\" *\n    read(\"../../example_github_workflow_files/automerge.yml\", String) *\n    \"\\n```\"\n@eval Markdown.@md_str($str)","category":"section"},{"location":"configuration/#AutoMerge.RegistryConfiguration","page":"Configuration","title":"AutoMerge.RegistryConfiguration","text":"RegistryConfiguration\n\nShared configuration fields used by both PR checking and merging functionality.\n\nRegistryConfiguration(; kwargs...)\nRegistryConfiguration(config::RegistryConfiguration; kwargs...)  # Override constructor\n\nThe second form creates a config with specified fields overridden, e.g., RegistryConfiguration(config; read_only=true).\n\nnote: Note\nNew keyword arguments with defaults may be added to this struct in non-breaking releases of AutoMerge.jl. Default values and keyword argument names will not be removed or changed in non-breaking releases, however.\n\nRequired keyword arguments (& fields)\n\nregistry::String: the registry name you want to run AutoMerge on.\nauthorized_authors::Vector{String}: list of who can submit registration, e.g String[\"JuliaRegistrator\"].\nauthorized_authors_special_jll_exceptions::Vector{String}: a list of users who can submit JLL packages (which have strict rules about allowed dependencies and are subject to new_jll_*_waiting_minutess instead of new_*_waiting_minutess).\nnew_package_waiting_minutes::Dates.Minute: new package waiting period in minutes.\nnew_jll_package_waiting_minutes::Dates.Minute: new JLL package waiting period in minutes.\nnew_version_waiting_minutes::Dates.Minute: new package version waiting period in minutes.\nnew_jll_version_waiting_minutes::Dates.Minute: new JLL package version waiting period in minutes.\n\nKeyword arguments (& fields) with default values\n\nmaster_branch::String = \"master\": name of master_branch, e.g you may want to specify this to \"main\" for new GitHub repositories.\nerror_exit_if_automerge_not_applicable::Bool = false: if false, AutoMerge will not error on PRs made by non-AutoMerge-authorized users\napi_url::String = \"https://api.github.com\": the registry host API URL.\nread_only::Bool = false: run in read only mode.\n\n\n\n\n\n","category":"type"},{"location":"configuration/#AutoMerge.CheckPRConfiguration","page":"Configuration","title":"AutoMerge.CheckPRConfiguration","text":"CheckPRConfiguration\n\nConfiguration struct for checking PR registration validity (security-isolated functionality).\n\nCheckPRConfiguration(; kwargs...)\nCheckPRConfiguration(config::CheckPRConfiguration; kwargs...)  # Override constructor\n\nThe second form creates a config with specified fields overridden, e.g., CheckPRConfiguration(config; check_license=false).\n\nnote: Note\nNew keyword arguments with defaults may be added to this struct in non-breaking releases of AutoMerge.jl. Default values and keyword argument names will not be removed or changed in non-breaking releases, however.\n\nKeyword arguments (& fields) with default values\n\nmaster_branch_is_default_branch::Bool = true: if master_branch specified above is the default branch.\nsuggest_onepointzero::Bool = true: should the AutoMerge comment include a suggestion to tag a 1.0 release for v0.x.y packages.\npoint_to_slack::Bool = false: should the AutoMerge comment recommend sending a message to the #pkg-registration Julia-Slack channel when auto-merging is not possible.\nregistry_deps::Vector{String} = String[]: list of registry dependencies, e.g your packages may depend on General.\ncheck_license::Bool = false: check package has a valid license.\ncheck_breaking_explanation::Bool = false: Check whether the PR has release notes (collected via Registrator.jl) with a breaking change explanation.\npublic_registries::Vector{String} = String[]: If a new package registration has a UUID that matches that of a package already registered in one of these registries supplied here (and has either a different name or different URL) then an error will be thrown. This to prevent AutoMerge from being used for \"dependency confusion\" attacks on those registries.\nenvironment_variables_to_pass::Vector{String} = String[]: Environment variables to pass to the subprocess that does Pkg.add(\"Foo\") and import Foo\ncommit_status_token_name::String = \"AUTOMERGE_GITHUB_TOKEN\": Name of the environment variable containing the GitHub token used for PR validation. The token stored in this environment variable needs repo:status permission to set commit statuses and read access to PRs, but does not need write access to the repository.\n\n\n\n\n\n","category":"type"},{"location":"configuration/#AutoMerge.MergePRsConfiguration","page":"Configuration","title":"AutoMerge.MergePRsConfiguration","text":"MergePRsConfiguration\n\nConfiguration struct for merging approved PRs (requires merge permissions).\n\nMergePRsConfiguration(; kwargs...)\nMergePRsConfiguration(config::MergePRsConfiguration; kwargs...)  # Override constructor\n\nThe second form creates a config with specified fields overridden, e.g., MergePRsConfiguration(config; merge_new_packages=false).\n\nnote: Note\nNew keyword arguments with defaults may be added to this struct in non-breaking releases of AutoMerge.jl. Default values and keyword argument names will not be removed or changed in non-breaking releases, however.\n\nKeyword arguments (& fields) with default values\n\nmerge_new_packages::Bool = true: should AutoMerge merge registration PRs for new packages\nmerge_new_versions::Bool = true: should AutoMerge merge registration PRs for new versions of packages\nadditional_statuses::Vector{String} = String[]: list of additional commit statuses that must pass before AutoMerge will merge a PR\nadditional_check_runs::Vector{String} = String[]: list of additional check runs that must pass before AutoMerge will merge a PR\nmerge_token_name::String = \"AUTOMERGE_MERGE_TOKEN\": Name of the environment variable containing the GitHub token used for PR merging. The token stored in this environment variable needs write access to the repository to merge PRs.\n\n\n\n\n\n","category":"type"},{"location":"configuration/#AutoMerge.AutoMergeConfiguration","page":"Configuration","title":"AutoMerge.AutoMergeConfiguration","text":"AutoMergeConfiguration\n\nCombined configuration object containing registry, PR checking, and PR merging settings.\n\nAutoMergeConfiguration(; registry_config, check_pr_config, merge_prs_config)\nAutoMergeConfiguration(config::AutoMergeConfiguration; kwargs...)  # Override constructor\n\nThe second form creates a config with specified sub-configs overridden, e.g., AutoMergeConfiguration(config; registry_config=new_reg_config).\n\nnote: Note\nNew keyword arguments with defaults may be added to this struct in non-breaking releases of AutoMerge.jl. Default values and keyword argument names will not be removed or changed in non-breaking releases, however.\n\nKeyword arguments & fields\n\nregistry_config::RegistryConfiguration: Shared registry settings\ncheck_pr_config::CheckPRConfiguration: PR validation settings\nmerge_prs_config::MergePRsConfiguration: PR merging settings\n\n\n\n\n\n","category":"type"},{"location":"configuration/#AutoMerge.general_registry_config","page":"Configuration","title":"AutoMerge.general_registry_config","text":"AutoMerge.general_registry_config()\n\nThis is the AutoMerge.AutoMergeConfiguration object containing shared configuration for the General registry. This configuration is used by both PR checking and merging functionality.\n\nwarning: Warning\nThe values of the fields chosen here may change in non-breaking releases of AutoMerge.jl at the discretion of the maintainers of the General registry.\n\nHere are the settings chosen for General in this version of AutoMerge.jl:\n\njulia> AutoMerge.general_registry_config()\nAutoMerge.AutoMergeConfiguration with:\n  registry_config:\n    registry: `\"JuliaRegistries/General\"`\n    authorized_authors: `[\"JuliaRegistrator\"]`\n    authorized_authors_special_jll_exceptions: `[\"jlbuild\"]`\n    new_package_waiting_minutes: `Dates.Minute(4320)`\n    new_jll_package_waiting_minutes: `Dates.Minute(20)`\n    new_version_waiting_minutes: `Dates.Minute(10)`\n    new_jll_version_waiting_minutes: `Dates.Minute(10)`\n    master_branch: `\"master\"`\n    error_exit_if_automerge_not_applicable: `false`\n    api_url: `\"https://api.github.com\"`\n    read_only: `false`\n  check_pr_config:\n    master_branch_is_default_branch: `true`\n    suggest_onepointzero: `false`\n    point_to_slack: `true`\n    registry_deps: `String[]`\n    check_license: `true`\n    check_breaking_explanation: `true`\n    public_registries: `[\"https://github.com/HolyLab/HolyLabRegistry\", \"https://github.com/cossio/CossioJuliaRegistry\"]`\n    environment_variables_to_pass: `String[]`\n    commit_status_token_name: `\"AUTOMERGE_GITHUB_TOKEN\"`\n  merge_prs_config:\n    merge_new_packages: `true`\n    merge_new_versions: `true`\n    additional_statuses: `String[]`\n    additional_check_runs: `String[]`\n    merge_token_name: `\"AUTOMERGE_MERGE_TOKEN\"`\n\n\n\n\n\n\n","category":"function"},{"location":"configuration/#AutoMerge.read_config","page":"Configuration","title":"AutoMerge.read_config","text":"read_config(path) -> AutoMergeConfiguration\n\nRead an AutoMerge configuration from a TOML file.\n\n\n\n\n\n","category":"function"},{"location":"configuration/#AutoMerge.write_config","page":"Configuration","title":"AutoMerge.write_config","text":"write_config(path, config::AbstractConfiguration) -> Nothing\n\nWrite an AutoMerge configuration to a TOML file. Automatically handles serialization of Dates.Minute fields to integer values.\n\n\n\n\n\n","category":"function"},{"location":"#[RegistryCI.jl](https://github.com/JuliaRegistries/RegistryCI.jl)","page":"Home","title":"RegistryCI.jl","text":"RegistryCI.jl provides continuous integration (CI) tools for Julia package registries, including registry consistency testing, automatic merging (automerge) of pull requests, and automatic TagBot triggers.","category":"section"},{"location":"internals/#Internals","page":"Internals (Private)","title":"Internals","text":"","category":"section"},{"location":"internals/#RegistryCI","page":"Internals (Private)","title":"RegistryCI","text":"","category":"section"},{"location":"internals/#AutoMerge","page":"Internals (Private)","title":"AutoMerge","text":"","category":"section"},{"location":"internals/#RegistryCI.test","page":"Internals (Private)","title":"RegistryCI.test","text":"test(path)\n\nRun various checks on the registry located at path. Checks for example that all files are parsable and understandable by Pkg and consistency between Registry.toml and each Package.toml.\n\nIf your registry has packages that have dependencies that are registered in other registries elsewhere, then you may provide the github urls for those registries using the registry_deps parameter.\n\n\n\n\n\n","category":"function"},{"location":"internals/#AutoMerge.extract_github_owner_repo-Tuple{AbstractString}","page":"Internals (Private)","title":"AutoMerge.extract_github_owner_repo","text":"extract_github_owner_repo(repo_url::AbstractString)\n\nExtracts the owner and repository name from a GitHub URL. Returns a tuple (owner, repo) or nothing if the URL is not a valid GitHub URL.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.find_previous_semver_version-Tuple{AbstractString, VersionNumber, AbstractString}","page":"Internals (Private)","title":"AutoMerge.find_previous_semver_version","text":"find_previous_semver_version(pkg::AbstractString, current_version::VersionNumber, registry_path::AbstractString) -> Union{VersionNumber, Nothing}\n\nFinds the previous semver version for a package. Returns the maximum version that is less than the current version, or nothing if there are no previous versions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.format_github_diff_url-Tuple{AbstractString, AbstractString, AbstractString}","page":"Internals (Private)","title":"AutoMerge.format_github_diff_url","text":"format_github_diff_url(repo_url::AbstractString, previous_commit_sha::AbstractString, current_commit_sha::AbstractString) -> Union{AbstractString, Nothing}\n\nGenerates a GitHub diff URL comparing two commits. Returns the URL AbstractString, or nothing if the repository is not on GitHub.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.get_all_pkg_name_uuids-Tuple{AbstractString}","page":"Internals (Private)","title":"AutoMerge.get_all_pkg_name_uuids","text":"get_all_pkg_name_uuids(registry_dir::AbstractString)\nget_all_pkg_name_uuids(registry::RegistryInstance)\n\nGiven either a path to an uncompressed registry directory or a RegistryInstance object (from RegistryInstances.jl), returns a sorted vector of NamedTuples with name and uuid fields for all packages in the registry and Julia's standard libraries.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.get_version_diff_info-Tuple{Any}","page":"Internals (Private)","title":"AutoMerge.get_version_diff_info","text":"get_version_diff_info(data) -> Union{NamedTuple, Nothing}\n\nGets diff information for a new version registration. Returns a NamedTuple with fields:\n\ndiff_stats: string summarizing the git diff between package versions\ndiff_url: GitHub diff URL, if available. Otherwise nothing.\nprevious_version: Previous version number\ncurrent_version: Current version number\n\nReturns nothing if no previous version exists or package is not a NewVersion.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.is_github_repo-Tuple{AbstractString}","page":"Internals (Private)","title":"AutoMerge.is_github_repo","text":"is_github_repo(repo_url::AbstractString) -> Bool\n\nChecks if a repository URL is a GitHub repository.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.load_files_from_url_and_tree_hash-Tuple{Any, Vararg{String, 4}}","page":"Internals (Private)","title":"AutoMerge.load_files_from_url_and_tree_hash","text":"load_files_from_url_and_tree_hash(f, destination::String, url::String, tree_hash::String, pkg_clone_dir::String) -> Bool\n\nAttempts to clone a git repo from url into pkg_clone_dir (or reuse existing clone if it exists), runs f(dir) on that directory, then extract the files and folders from a given tree_hash, placing them in destination.\n\nThe repository is cloned into pkg_clone_dir.\n\nReturns a boolean indicating if the cloning succeeded.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.maybe_create_blocked_label-Tuple{Any, Any}","page":"Internals (Private)","title":"AutoMerge.maybe_create_blocked_label","text":"maybe_create_blocked_label(api, repo)\n\nAdd the label AutoMerge: last run blocked by comment to the repo if it doesn't already exist.\n\nReturns whether or not it created the label.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.parse_registry_pkg_info","page":"Internals (Private)","title":"AutoMerge.parse_registry_pkg_info","text":"parse_registry_pkg_info(registry_path, pkg, version=nothing) -> @NamedTuple{uuid::String, repo::String, subdir::String, tree_hash::Union{Nothing, String}}\n\nSearches the registry located at registry_path for a package with name pkg. Upon finding it, it parses the associated Package.toml file and returns the UUID and repository URI, and subdir.\n\nIf version is supplied, then the associated tree_hash will be returned. Otherwise, tree_hash will be nothing.\n\n\n\n\n\n","category":"function"},{"location":"internals/#AutoMerge.tree_sha_to_commit_sha-Tuple{AbstractString, AbstractString}","page":"Internals (Private)","title":"AutoMerge.tree_sha_to_commit_sha","text":"tree_sha_to_commit_sha(tree_sha::AbstractString, clone_dir::AbstractString; subdir::AbstractString=\"\") -> Union{AbstractString, Nothing}\n\nConverts a git tree SHA to a commit SHA by finding a commit that has that tree. Returns the commit SHA string, or nothing if no commit is found.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.try_remove_label-NTuple{4, Any}","page":"Internals (Private)","title":"AutoMerge.try_remove_label","text":"try_remove_label(api, repo, issue, label)\n\nUses GitHub.remove_label to remove the label, if it exists. Differs from the upstream functionality by not erroring if we receive a 404 response indicating the label did not exist.\n\nReturns whether or not the label was removed.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.uuid_passes_sanity_check-Tuple{Base.UUID}","page":"Internals (Private)","title":"AutoMerge.uuid_passes_sanity_check","text":"uuid_passes_sanity_check(uuid::UUID) -> Bool\n\nChecks if a UUID conforms to RFC 4122 / RFC 9562 standards or is a historically buggy Julia version 1 UUID.\n\nStandards-compliant UUIDs must have:\n\nVersion field (bits 48-51): 1-8\nVariant field (bits 64-65): 10 binary (making the hex character at position 19 one of 8, 9, a, or b)\n\nJulia's uuid1() implementation historically had a bug where it set the variant bits to 00 instead of 10. We allow these for backward compatibility.\n\nReturns true if the UUID passes the sanity check, false otherwise.\n\n\n\n\n\n","category":"method"}]
}
