var documenterSearchIndex = {"docs":
[{"location":"guidelines/#Automatic-merging-guidelines","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"","category":"section"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"These are the guidelines that a pull request must pass in order to be automatically merged.","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"All of those guidelines are enabled on the General registry.","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"For other registries, some of these guidelines can be disabled.","category":"page"},{"location":"guidelines/#New-packages","page":"Automatic merging guidelines","title":"New packages","text":"","category":"section"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"import RegistryCI\nimport AutoMerge\nimport Markdown\n\nfunction guidelines_to_markdown_output(guidelines_function::Function)\n    guidelines = guidelines_function(\n        registration_type;\n        check_license = true,\n        check_breaking_explanation = true,\n        this_is_jll_package = false,\n        this_pr_can_use_special_jll_exceptions = false,\n        use_distance_check = false,\n        package_author_approved = false,\n    )\n    filter!(x -> !(x[1] isa Symbol), guidelines)\n    filter!(x -> !(x[1].docs isa Nothing), guidelines)\n    docs = [rstrip(x[1].docs) for x in guidelines]\n    output_string = join(string.(collect(1:length(docs)), Ref(\". \"), docs), \"\\n\")\n    output_markdown = Markdown.parse(output_string)\n    return output_markdown\nend\n\nconst guidelines_function = AutoMerge.get_automerge_guidelines\nconst registration_type = AutoMerge.NewPackage()\nconst output_markdown = guidelines_to_markdown_output(guidelines_function)\n\nreturn output_markdown","category":"page"},{"location":"guidelines/#New-versions-of-existing-packages","page":"Automatic merging guidelines","title":"New versions of existing packages","text":"","category":"section"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"import RegistryCI\nimport AutoMerge\nimport Markdown\n\nfunction guidelines_to_markdown_output(guidelines_function::Function)\n    guidelines = guidelines_function(\n        registration_type;\n        check_license = true,\n        check_breaking_explanation = true,\n        this_is_jll_package = false,\n        this_pr_can_use_special_jll_exceptions = false,\n        use_distance_check = false,\n        package_author_approved = false,\n    )\n    filter!(x -> !(x[1] isa Symbol), guidelines)\n    filter!(x -> !(x[1].docs isa Nothing), guidelines)\n    docs = [rstrip(x[1].docs) for x in guidelines]\n    output_string = join(string.(collect(1:length(docs)), Ref(\". \"), docs), \"\\n\")\n    output_markdown = Markdown.parse(output_string)\n    return output_markdown\nend\n\nconst guidelines_function = AutoMerge.get_automerge_guidelines\nconst registration_type = AutoMerge.NewVersion()\nconst output_markdown = guidelines_to_markdown_output(guidelines_function)\n\nreturn output_markdown","category":"page"},{"location":"guidelines/#Additional-information","page":"Automatic merging guidelines","title":"Additional information","text":"","category":"section"},{"location":"guidelines/#Upper-bounded-[compat]-entries","page":"Automatic merging guidelines","title":"Upper-bounded [compat] entries","text":"","category":"section"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"For example, the following [compat] entries meet the criteria for automatic merging:","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"[compat]\nPackageA = \"1\"          # [1.0.0, 2.0.0), has upper bound (good)\nPackageB = \"0.1, 0.2\"   # [0.1.0, 0.3.0), has upper bound (good)","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"The following [compat] entries do NOT meet the criteria for automatic merging:","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"[compat]\nPackageC = \">=3\"        # [3.0.0, ∞), no upper bound (bad)\nPackageD = \">=0.4, <1\"  # [0, ∞), no lower bound, no upper bound (very bad)","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"Please note: each [compat] entry must include only a finite number of breaking releases. Therefore, the following [compat] entries do NOT meet the criteria for automatic merging:","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"[compat]\nPackageE = \"0\"          # includes infinitely many breaking 0.x releases of PackageE (bad)\nPackageF = \"0.2 - 0\"    # includes infinitely many breaking 0.x releases of PackageF (bad)\nPackageG = \"0.2 - 1\"    # includes infinitely many breaking 0.x releases of PackageG (bad)","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"See Pkg's documentation for specification of [compat] entries in your Project.toml file.","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"(Note: JLL dependencies are excluded from this criterion because they often have non-standard version numbering schemes; however, this may change in the future.)","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"You may find CompatHelper.jl and PackageCompatUI.jl helpful for maintaining up-to-date [compat] entries.","category":"page"},{"location":"guidelines/#Testing-that-the-package-can-be-imported","page":"Automatic merging guidelines","title":"Testing that the package can be imported","text":"","category":"section"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"AutoMerge tests whether the registered package/version can be imported. This is done using the lowest and highest Julia minor versions according to the Julia compat declared in Project.toml. For the chosen minor versions, the highest compatible patch version is used. There are two special cases:","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"For technical reasons 1.0.x versions cannot be used, so effectively 1.1 is the lowest considered minor version.\nIf a package only is compatible with a Julia version in prerelease testing phase, the highest available prerelease version (e.g. a beta or a release candidate) is used for import testing. Otherwise prereleases are not used.","category":"page"},{"location":"guidelines/#Name-similarity-distance-check","page":"Automatic merging guidelines","title":"Name similarity distance check","text":"","category":"section"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"These checks and tolerances are subject to change in order to improve the process.","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"To test yourself that a tentative package name, say MyPackage meets these checks, you can use the following code (after adding the RegistryCI package to your Julia environment):","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"using RegistryCI, RegistryInstances\nusing AutoMerge\npath_to_registry = joinpath(DEPOT_PATH[1], \"registries\", \"General.toml\")\nall_pkg_names = AutoMerge.get_all_non_jll_package_names(RegistryInstance(path_to_registry))\nAutoMerge.meets_distance_check(\"MyPackage123\", all_pkg_names)","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"where path_to_registry is a path to the registry of interest. For the General Julia registry, usually path_to_registry = joinpath(DEPOT_PATH[1], \"registries\", \"General.toml\") if you haven't changed your DEPOT_PATH (or path_to_registry = joinpath(DEPOT_PATH[1], \"registries\", \"General\") if you have an uncompressed registry at the directory there). This will return a boolean, indicating whether or not your tentative package name passed the check, as well as a string, indicating what the problem is in the event the check did not pass.","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"Note that these automerge guidelines are deliberately conservative: it is very possible for a perfectly good name to not pass the automatic checks. They simply exist to provide a fast path so that manual review is not required for every new package. False positives can be overridden with a PR label after manual review.","category":"page"},{"location":"guidelines/#Providing-and-updating-release-notes","page":"Automatic merging guidelines","title":"Providing and updating release notes","text":"","category":"section"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"When invoking a registration with the @JuliaRegister bot, release notes can be added in the form","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"@JuliaRegistrator register\n\nRelease notes:\n\n## Breaking changes\n\n- Explanation of breaking change, ideally with upgrade tips\n- ...","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"These can also be added/updated on the General PR by re-invoking with the above.","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"Doing this has two benefits:","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"helps explanations during the registration process, especially for breaking changes\nrelease notes are picked up by TagBot such that they are added to the new release on the original repo","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"Automerge is disabled for breaking changes where release notes are not provided mentioning \"breaking\" (or \"changelog\" if there is a repository file that you prefer to direct users to).","category":"page"},{"location":"guidelines/#List-of-all-GitHub-PR-labels-that-can-influence-AutoMerge","page":"Automatic merging guidelines","title":"List of all GitHub PR labels that can influence AutoMerge","text":"","category":"section"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"AutoMerge reads certain labels on GitHub registration pull requests to influence its decisions. Specifically, these labels are:","category":"page"},{"location":"guidelines/","page":"Automatic merging guidelines","title":"Automatic merging guidelines","text":"Override AutoMerge: name similarity is okay\nThis label can be manually applied by folks with triage-level access to the registry repository.\nAutoMerge skips the \"name similarity check\" on new package registration PRs with this label.\nOverride AutoMerge: package author approved\nThis label can be manually applied, but typically is applied by a separate Github Actions workflow which monitors the PR for comments by the package author, and applies this label if they write [merge approved].\nThis label currently only skips the \"sequential version number\" check in new versions. In the future, the author-approval mechanism may be used for other checks (on both \"new version\" registrations and also \"new package\" registrations).\nWhen AutoMerge fails a check that can be skipped by author-approval, it will mention so in the comment, and direct authors to comment [merge approved] if they want to skip the check.","category":"page"},{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/#RegistryCI","page":"Public API","title":"RegistryCI","text":"","category":"section"},{"location":"public/#RegistryCI.test","page":"Public API","title":"RegistryCI.test","text":"test(path)\n\nRun various checks on the registry located at path. Checks for example that all files are parsable and understandable by Pkg and consistency between Registry.toml and each Package.toml.\n\nIf your registry has packages that have dependencies that are registered in other registries elsewhere, then you may provide the github urls for those registries using the registry_deps parameter.\n\n\n\n\n\n","category":"function"},{"location":"public/#AutoMerge","page":"Public API","title":"AutoMerge","text":"","category":"section"},{"location":"public/#AutoMerge.check_pr","page":"Public API","title":"AutoMerge.check_pr","text":"check_pr(; registry, authorized_authors, ..., env=ENV, cicfg=auto_detect_ci_service(; env=env))\n\nCheck a pull request for registration validity. This entrypoint runs untrusted code and does not require merge permissions.\n\nRequired Arguments\n\nregistry::String: the registry name you want to run AutoMerge on.\nauthorized_authors::Vector{String}: list of who can submit registration, e.g String[\"JuliaRegistrator\"].\nauthorized_authors_special_jll_exceptions::Vector{String}: a list of users who can submit JLL packages.\nnew_package_waiting_minutes::Dates.Minute: new package waiting period in minutes.\nnew_jll_package_waiting_minutes::Dates.Minute: new JLL package waiting period in minutes.\nnew_version_waiting_minutes::Dates.Minute: new package version waiting period in minutes.\nnew_jll_version_waiting_minutes::Dates.Minute: new JLL package version waiting period in minutes.\n\nOptional Arguments\n\nmaster_branch::String = \"master\": name of master_branch.\nerror_exit_if_automerge_not_applicable::Bool = false: if false, AutoMerge will not error on PRs made by non-AutoMerge-authorized users\napi_url::String = \"https://api.github.com\": the registry host API URL.\nread_only::Bool = false: run in read only mode.\nmaster_branch_is_default_branch::Bool = true: if master_branch is the default branch.\nsuggest_onepointzero::Bool = true: should the AutoMerge comment include a suggestion to tag a 1.0 release.\npoint_to_slack::Bool = false: should the AutoMerge comment recommend sending a message to the #pkg-registration Julia-Slack channel.\nregistry_deps::Vector{<:AbstractString} = String[]: list of registry dependencies.\ncheck_license::Bool = false: check package has a valid license.\ncheck_breaking_explanation::Bool = false: Check whether the PR has breaking change explanation.\npublic_registries::Vector{<:AbstractString} = String[]: registries to check for UUID collisions.\nenvironment_variables_to_pass::Vector{<:AbstractString} = String[]: Environment variables to pass to subprocess.\ncommit_status_token_name::String = \"AUTOMERGE_GITHUB_TOKEN\": Name of environment variable containing GitHub token.\nenv: an AbstractDictionary used to read environmental variables from.\ncicfg: Configuration struct describing the continuous integration (CI) environment.\n\n\n\n\n\n","category":"function"},{"location":"public/#AutoMerge.merge_prs","page":"Public API","title":"AutoMerge.merge_prs","text":"merge_prs(; registry, authorized_authors, ..., env=ENV, cicfg=auto_detect_ci_service(; env=env))\n\nMerge approved pull requests. This entrypoint requires merge permissions and does not run untrusted code.\n\nRequired Arguments\n\nregistry::String: the registry name you want to run AutoMerge on.\nauthorized_authors::Vector{String}: list of who can submit registration, e.g String[\"JuliaRegistrator\"].\nauthorized_authors_special_jll_exceptions::Vector{String}: a list of users who can submit JLL packages.\nnew_package_waiting_minutes::Dates.Minute: new package waiting period in minutes.\nnew_jll_package_waiting_minutes::Dates.Minute: new JLL package waiting period in minutes.\nnew_version_waiting_minutes::Dates.Minute: new package version waiting period in minutes.\nnew_jll_version_waiting_minutes::Dates.Minute: new JLL package version waiting period in minutes.\n\nOptional Arguments\n\nmaster_branch::String = \"master\": name of master_branch.\nerror_exit_if_automerge_not_applicable::Bool = false: if false, AutoMerge will not error on PRs made by non-AutoMerge-authorized users\napi_url::String = \"https://api.github.com\": the registry host API URL.\nread_only::Bool = false: run in read only mode.\nmerge_new_packages::Bool = true: should AutoMerge merge registration PRs for new packages\nmerge_new_versions::Bool = true: should AutoMerge merge registration PRs for new versions of packages\nadditional_statuses::AbstractVector{<:AbstractString} = String[]: list of additional commit statuses that must pass\nadditional_check_runs::AbstractVector{<:AbstractString} = String[]: list of additional check runs that must pass\nmerge_token_name::String = \"AUTOMERGE_MERGE_TOKEN\": Name of environment variable containing GitHub token for PR merging.\nenv: an AbstractDictionary used to read environmental variables from.\ncicfg: Configuration struct describing the continuous integration (CI) environment.\n\n\n\n\n\n","category":"function"},{"location":"public/#AutoMerge.check_pr-Tuple{}","page":"Public API","title":"AutoMerge.check_pr","text":"check_pr(; registry, authorized_authors, ..., env=ENV, cicfg=auto_detect_ci_service(; env=env))\n\nCheck a pull request for registration validity. This entrypoint runs untrusted code and does not require merge permissions.\n\nRequired Arguments\n\nregistry::String: the registry name you want to run AutoMerge on.\nauthorized_authors::Vector{String}: list of who can submit registration, e.g String[\"JuliaRegistrator\"].\nauthorized_authors_special_jll_exceptions::Vector{String}: a list of users who can submit JLL packages.\nnew_package_waiting_minutes::Dates.Minute: new package waiting period in minutes.\nnew_jll_package_waiting_minutes::Dates.Minute: new JLL package waiting period in minutes.\nnew_version_waiting_minutes::Dates.Minute: new package version waiting period in minutes.\nnew_jll_version_waiting_minutes::Dates.Minute: new JLL package version waiting period in minutes.\n\nOptional Arguments\n\nmaster_branch::String = \"master\": name of master_branch.\nerror_exit_if_automerge_not_applicable::Bool = false: if false, AutoMerge will not error on PRs made by non-AutoMerge-authorized users\napi_url::String = \"https://api.github.com\": the registry host API URL.\nread_only::Bool = false: run in read only mode.\nmaster_branch_is_default_branch::Bool = true: if master_branch is the default branch.\nsuggest_onepointzero::Bool = true: should the AutoMerge comment include a suggestion to tag a 1.0 release.\npoint_to_slack::Bool = false: should the AutoMerge comment recommend sending a message to the #pkg-registration Julia-Slack channel.\nregistry_deps::Vector{<:AbstractString} = String[]: list of registry dependencies.\ncheck_license::Bool = false: check package has a valid license.\ncheck_breaking_explanation::Bool = false: Check whether the PR has breaking change explanation.\npublic_registries::Vector{<:AbstractString} = String[]: registries to check for UUID collisions.\nenvironment_variables_to_pass::Vector{<:AbstractString} = String[]: Environment variables to pass to subprocess.\ncommit_status_token_name::String = \"AUTOMERGE_GITHUB_TOKEN\": Name of environment variable containing GitHub token.\nenv: an AbstractDictionary used to read environmental variables from.\ncicfg: Configuration struct describing the continuous integration (CI) environment.\n\n\n\n\n\n","category":"method"},{"location":"public/#AutoMerge.merge_prs-Tuple{}","page":"Public API","title":"AutoMerge.merge_prs","text":"merge_prs(; registry, authorized_authors, ..., env=ENV, cicfg=auto_detect_ci_service(; env=env))\n\nMerge approved pull requests. This entrypoint requires merge permissions and does not run untrusted code.\n\nRequired Arguments\n\nregistry::String: the registry name you want to run AutoMerge on.\nauthorized_authors::Vector{String}: list of who can submit registration, e.g String[\"JuliaRegistrator\"].\nauthorized_authors_special_jll_exceptions::Vector{String}: a list of users who can submit JLL packages.\nnew_package_waiting_minutes::Dates.Minute: new package waiting period in minutes.\nnew_jll_package_waiting_minutes::Dates.Minute: new JLL package waiting period in minutes.\nnew_version_waiting_minutes::Dates.Minute: new package version waiting period in minutes.\nnew_jll_version_waiting_minutes::Dates.Minute: new JLL package version waiting period in minutes.\n\nOptional Arguments\n\nmaster_branch::String = \"master\": name of master_branch.\nerror_exit_if_automerge_not_applicable::Bool = false: if false, AutoMerge will not error on PRs made by non-AutoMerge-authorized users\napi_url::String = \"https://api.github.com\": the registry host API URL.\nread_only::Bool = false: run in read only mode.\nmerge_new_packages::Bool = true: should AutoMerge merge registration PRs for new packages\nmerge_new_versions::Bool = true: should AutoMerge merge registration PRs for new versions of packages\nadditional_statuses::AbstractVector{<:AbstractString} = String[]: list of additional commit statuses that must pass\nadditional_check_runs::AbstractVector{<:AbstractString} = String[]: list of additional check runs that must pass\nmerge_token_name::String = \"AUTOMERGE_MERGE_TOKEN\": Name of environment variable containing GitHub token for PR merging.\nenv: an AbstractDictionary used to read environmental variables from.\ncicfg: Configuration struct describing the continuous integration (CI) environment.\n\n\n\n\n\n","category":"method"},{"location":"regexes/#Regexes","page":"Regexes","title":"Regexes","text":"","category":"section"},{"location":"regexes/","page":"Regexes","title":"Regexes","text":"In order for AutoMerge to work, each pull request (PR) must match the following regular expressions:","category":"page"},{"location":"regexes/","page":"Regexes","title":"Regexes","text":"import RegistryCI\nimport AutoMerge\nimport Markdown\n\nBase.@kwdef struct TableRow\n    regex::Regex\n    regex_str::String\n    pr_field::String\n    pr_type::String\n    example::String\nend\n\nescape_pipes(str::String) = replace(str, \"|\" => \"\\\\|\")\n\nfunction table_row(; regex::Regex,\n                     pr_field::String,\n                     pr_type::String,\n                     example::String)\n    regex_str = regex |> Base.repr |> escape_pipes\n    result = TableRow(;\n            regex,\n            regex_str,\n            pr_field,\n            pr_type,\n            example,\n        )\n    return result\nend\n\nconst row_1 = table_row(;\n    regex = AutoMerge.new_package_title_regex,\n    pr_field = \"PR title\",\n    pr_type = \"New packages\",\n    example = \"New package: HelloWorld v1.2.3\",\n)\n\nconst row_2 = table_row(;\n    regex = AutoMerge.new_version_title_regex,\n    pr_field = \"PR title\",\n    pr_type = \"New versions\",\n    example = \"New version: HelloWorld v1.2.3\",\n)\n\nconst row_3 = table_row(;\n    regex = AutoMerge.commit_regex,\n    pr_field = \"PR body\",\n    pr_type = \"All\",\n    example = \"* Commit: 012345678901234567890123456789abcdef0000\",\n)\n\nconst rows = [\n    row_1,\n    row_2,\n    row_3,\n]\n\nfor row in rows\n    regex_occurs_in_example = occursin(row.regex, row.example)\n    if !regex_occurs_in_example\n        @error(\"Regex does not occur in example\", row.regex, row.example)\n        throw(ErrorException(\"Regex `$(row.regex)` does not occur in example \\\"$(row.example)\\\"\"))\n    end\nend\n\nconst markdown_lines = String[\n    \"| Regex | Field | PR Type | Example |\",\n    \"| ----- | ----- | ------- | ------- |\",\n]\n\nfor row in rows\n    line = \"| `$(row.regex_str)` | $(row.pr_field) | $(row.pr_type) | `$(row.example)` |\"\n    push!(markdown_lines, line)\nend\n\nconst markdown_string = join(markdown_lines, \"\\n\")\nconst markdown_parsed = Markdown.parse(markdown_string)\n\nreturn markdown_parsed","category":"page"},{"location":"private-registries/#Using-RegistryCI-on-your-own-package-registry","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"","category":"section"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"In order to create and maintain a custom Julia registry, you can use LocalRegistry.jl. After you have the registry configured, you can setup CI using RegistryCI by following how it is used in the General registry.","category":"page"},{"location":"private-registries/#Basic-configuration","page":"Using RegistryCI on your own package registry","title":"Basic configuration","text":"","category":"section"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"You will first need to copy the .ci folder in the root of the General registry to the root of your own registry. This folder contains some resources required for the RegistryCI package to work and update itself. If you do not need AutoMerge support, there is no need to copy the stopwatch.jl file in the .ci folder.","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"Next, you will need to copy the registry-consistency-ci.yml and update_manifest.yml workflow files.","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"The registry-consistency-ci.yml file should be modified as follows if you have packages in your registry that depend on packages in the General registry. If the packages in your registry depend on packages in other registries, they should also be added to registry_deps","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"- run: julia --project=.ci/ --color=yes -e 'import RegistryCI; RegistryCI.test()'\n\n+ run: julia --project=.ci/ --color=yes -e 'import RegistryCI; RegistryCI.test(registry_deps=[\"https://github.com/JuliaRegistries/General\"])'","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"You can optionally use the registry name instead of the URL:","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"- run: julia --project=.ci/ --color=yes -e 'import RegistryCI; RegistryCI.test()'\n+ run: julia --project=.ci/ --color=yes -e 'import RegistryCI; RegistryCI.test(registry_deps=[\"General\"])'","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"If Julia pkg server is available and recognized, then the Julia Pkg will try to download registry from it. This can be useful to reduce the unnecessary network traffic, for example, if you host a private pkg server in your local network(e.g., enterprise network with firewall) and properly set up the environment variable JULIA_PKG_SERVER, then the network traffic doesn't need to pass through the proxy to GitHub.","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"warning: Warning\nRegistry fetched from Julia pkg server currently has some observable latency(e.g., hours). Check here for more information.","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"The self-update mechanism mentioned above uses a TAGBOT_TOKEN secret in order to create a pull request with the update. This secret is a personal access token which must have the repo scope enabled. To create the repository secret follow the instructions here. Use the name TAGBOT_TOKEN and the new PAT as the value.","category":"page"},{"location":"private-registries/#TagBot-triggers","page":"Using RegistryCI on your own package registry","title":"TagBot triggers","text":"","category":"section"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"If you want to use TagBot in the packages that you register in your registry, you need to also copy the TagBotTriggers.yml file. That workflow file also needs the TAGBOT_TOKEN secret mentioned above. In the TagBot.yml workflows of the registered packages you will also need to add the registry input as stated in the TagBot readme","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"with:\n  token: ${{ secrets.GITHUB_TOKEN }}\n  registry: MyOrg/MyRegistry","category":"page"},{"location":"private-registries/#AutoMerge-support","page":"Using RegistryCI on your own package registry","title":"AutoMerge support","text":"","category":"section"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"In order to enable automerge support, you will also have to copy the automerge.yml file and change the AutoMerge invocation appropriately","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"using AutoMerge\nusing Dates\nAutoMerge.run(\n    merge_new_packages = ENV[\"MERGE_NEW_PACKAGES\"] == \"true\",\n    merge_new_versions = ENV[\"MERGE_NEW_VERSIONS\"] == \"true\",\n    new_package_waiting_period = Day(3),\n    new_jll_package_waiting_period = Minute(20),\n    new_version_waiting_period = Minute(10),\n    new_jll_version_waiting_period = Minute(10),\n    registry = \"MyOrg/MyRegistry\",\n    tagbot_enabled = true,\n    authorized_authors = String[\"TrustedUser\"],\n    authorized_authors_special_jll_exceptions = String[\"\"],\n    suggest_onepointzero = false,\n    additional_statuses = String[],\n    additional_check_runs = String[],\n    check_license = true,\n    check_breaking_explanation = true,\n    public_registries = String[\"https://github.com/HolyLab/HolyLabRegistry\"],\n)","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"Most importantly, the following should be changed","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"registry = \"MyOrg/MyRegistry\",\nauthorized_authors = String[\"TrustedUser\"],","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"You will also have to make the following change in .ci/stopwatch.jl","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"- registry = GitHub.Repo(\"JuliaRegistries/General\")\n+ registry = GitHub.Repo(\"MyOrg/MyRegistry\")","category":"page"},{"location":"private-registries/#Note-regarding-private-registries","page":"Using RegistryCI on your own package registry","title":"Note regarding private registries","text":"","category":"section"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"In the case of a private registry, you might get permission errors when executing the instantiate.sh script. In that case you will also have to add the following","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"  - run: chmod 400 .ci/Project.toml\n  - run: chmod 400 .ci/Manifest.toml\n+ - run: chmod +x .ci/instantiate.sh","category":"page"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"in registry-consistency-ci.yml and also TagBotTriggers.yml and automerge.yml (in which the above appears twice) files if those features are used.","category":"page"},{"location":"private-registries/#Author-approval-workflow-support","page":"Using RegistryCI on your own package registry","title":"Author approval workflow support","text":"","category":"section"},{"location":"private-registries/","page":"Using RegistryCI on your own package registry","title":"Using RegistryCI on your own package registry","text":"Some guidelines allow the person invoking registration (typically the package author) to \"approve\" AutoMerge even if the guideline is not passing. This is facilitated by a labelling workflow author_approval.yml that must run on the registry in order to translate author-approval comments into labels that AutoMerge can use. The General registry's workflows should once again be used as an example.","category":"page"},{"location":"#[RegistryCI.jl](https://github.com/JuliaRegistries/RegistryCI.jl)","page":"Home","title":"RegistryCI.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RegistryCI.jl provides continuous integration (CI) tools for Julia package registries, including registry consistency testing, automatic merging (automerge) of pull requests, and automatic TagBot triggers.","category":"page"},{"location":"internals/#Internals","page":"Internals (Private)","title":"Internals","text":"","category":"section"},{"location":"internals/#RegistryCI","page":"Internals (Private)","title":"RegistryCI","text":"","category":"section"},{"location":"internals/#RegistryCI.test","page":"Internals (Private)","title":"RegistryCI.test","text":"test(path)\n\nRun various checks on the registry located at path. Checks for example that all files are parsable and understandable by Pkg and consistency between Registry.toml and each Package.toml.\n\nIf your registry has packages that have dependencies that are registered in other registries elsewhere, then you may provide the github urls for those registries using the registry_deps parameter.\n\n\n\n\n\n","category":"function"},{"location":"internals/#AutoMerge","page":"Internals (Private)","title":"AutoMerge","text":"","category":"section"},{"location":"internals/#AutoMerge.extract_github_owner_repo-Tuple{AbstractString}","page":"Internals (Private)","title":"AutoMerge.extract_github_owner_repo","text":"extract_github_owner_repo(repo_url::AbstractString)\n\nExtracts the owner and repository name from a GitHub URL. Returns a tuple (owner, repo) or nothing if the URL is not a valid GitHub URL.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.find_previous_semver_version-Tuple{AbstractString, VersionNumber, AbstractString}","page":"Internals (Private)","title":"AutoMerge.find_previous_semver_version","text":"find_previous_semver_version(pkg::AbstractString, current_version::VersionNumber, registry_path::AbstractString) -> Union{VersionNumber, Nothing}\n\nFinds the previous semver version for a package. Returns the maximum version that is less than the current version, or nothing if there are no previous versions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.format_github_diff_url-Tuple{AbstractString, AbstractString, AbstractString}","page":"Internals (Private)","title":"AutoMerge.format_github_diff_url","text":"format_github_diff_url(repo_url::AbstractString, previous_commit_sha::AbstractString, current_commit_sha::AbstractString) -> Union{AbstractString, Nothing}\n\nGenerates a GitHub diff URL comparing two commits. Returns the URL AbstractString, or nothing if the repository is not on GitHub.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.get_all_non_jll_package_names-Tuple{AbstractString}","page":"Internals (Private)","title":"AutoMerge.get_all_non_jll_package_names","text":"get_all_non_jll_package_names(registry_dir::AbstractString) -> Vector{String}\nget_all_non_jll_package_names(registry::RegistryInstance) -> Vector{String}\n\nGiven either:\n\na path to a directory holding an uncompressed registry\n\nor\n\na RegistryInstance object (from RegistryInstances.jl) associated to a registry,\n\nreturns a sorted list of the names of Julia's standard libraries and all the non-JLL packages defined in that registry.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.get_version_diff_info-Tuple{Any}","page":"Internals (Private)","title":"AutoMerge.get_version_diff_info","text":"get_version_diff_info(data) -> Union{NamedTuple, Nothing}\n\nGets diff information for a new version registration. Returns a NamedTuple with fields:\n\ndiff_stats: string summarizing the git diff between package versions\ndiff_url: GitHub diff URL, if available. Otherwise nothing.\nprevious_version: Previous version number\ncurrent_version: Current version number\n\nReturns nothing if no previous version exists or package is not a NewVersion.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.is_github_repo-Tuple{AbstractString}","page":"Internals (Private)","title":"AutoMerge.is_github_repo","text":"is_github_repo(repo_url::AbstractString) -> Bool\n\nChecks if a repository URL is a GitHub repository.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.load_files_from_url_and_tree_hash-Tuple{Any, Vararg{String, 4}}","page":"Internals (Private)","title":"AutoMerge.load_files_from_url_and_tree_hash","text":"load_files_from_url_and_tree_hash(f, destination::String, url::String, tree_hash::String, pkg_clone_dir::String) -> Bool\n\nAttempts to clone a git repo from url into pkg_clone_dir (or reuse existing clone if it exists), runs f(dir) on that directory, then extract the files and folders from a given tree_hash, placing them in destination.\n\nThe repository is cloned into pkg_clone_dir.\n\nReturns a boolean indicating if the cloning succeeded.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.maybe_create_blocked_label-Tuple{Any, Any}","page":"Internals (Private)","title":"AutoMerge.maybe_create_blocked_label","text":"maybe_create_blocked_label(api, repo)\n\nAdd the label AutoMerge: last run blocked by comment to the repo if it doesn't already exist.\n\nReturns whether or not it created the label.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.parse_registry_pkg_info","page":"Internals (Private)","title":"AutoMerge.parse_registry_pkg_info","text":"parse_registry_pkg_info(registry_path, pkg, version=nothing) -> @NamedTuple{uuid::String, repo::String, subdir::String, tree_hash::Union{Nothing, String}}\n\nSearches the registry located at registry_path for a package with name pkg. Upon finding it, it parses the associated Package.toml file and returns the UUID and repository URI, and subdir.\n\nIf version is supplied, then the associated tree_hash will be returned. Otherwise, tree_hash will be nothing.\n\n\n\n\n\n","category":"function"},{"location":"internals/#AutoMerge.tree_sha_to_commit_sha-Tuple{AbstractString, AbstractString}","page":"Internals (Private)","title":"AutoMerge.tree_sha_to_commit_sha","text":"tree_sha_to_commit_sha(tree_sha::AbstractString, clone_dir::AbstractString; subdir::AbstractString=\"\") -> Union{AbstractString, Nothing}\n\nConverts a git tree SHA to a commit SHA by finding a commit that has that tree. Returns the commit SHA string, or nothing if no commit is found.\n\n\n\n\n\n","category":"method"},{"location":"internals/#AutoMerge.try_remove_label-NTuple{4, Any}","page":"Internals (Private)","title":"AutoMerge.try_remove_label","text":"try_remove_label(api, repo, issue, label)\n\nUses GitHub.remove_label to remove the label, if it exists. Differs from the upstream functionality by not erroring if we receive a 404 response indicating the label did not exist.\n\nReturns whether or not the label was removed.\n\n\n\n\n\n","category":"method"}]
}
